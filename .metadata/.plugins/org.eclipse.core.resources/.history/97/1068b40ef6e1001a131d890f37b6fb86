package com.oracle.cgbu.cne.nrf.serviceHelper;
// Copyright 2018 (C), Oracle and/or its affiliates. All rights reserved.



import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import javax.servlet.http.HttpServletRequest;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;

import com.oracle.cgbu.cne.nrf.NrfConfigException;
import com.oracle.cgbu.cne.nrf.NrfException;
import com.oracle.cgbu.cne.nrf.config.NrfConfigurations;
import com.oracle.cgbu.cne.nrf.dao.NfInstance;
import com.oracle.cgbu.cne.nrf.dao.NfInstancesRepository;
import com.oracle.cgbu.cne.nrf.domain.ErrorCondition;
import com.oracle.cgbu.cne.nrf.domain.ErrorInfo;
import com.oracle.cgbu.cne.nrf.domain.FeatureStatus;
import com.oracle.cgbu.cne.nrf.domain.ForwardingData;
import com.oracle.cgbu.cne.nrf.domain.GenericResponse;
import com.oracle.cgbu.cne.nrf.domain.NFStatus;
import com.oracle.cgbu.cne.nrf.domain.NfProfile;
import com.oracle.cgbu.cne.nrf.domain.NrfEngSystemOptions;
import com.oracle.cgbu.cne.nrf.domain.NrfSystemOptions;
import com.oracle.cgbu.cne.nrf.domain.ProblemDetails;
import com.oracle.cgbu.cne.nrf.service.CommonService;
import com.oracle.cgbu.cne.nrf.service.CommonServiceImpl;

@Component
public class ValidationHelper {
	private static Logger logger = LogManager.getLogger(ValidationHelper.class);
	
	
	private static final int LOWER_DEFAULT_MAX_ALLOWED_WORKERS = 15;
    private static final int UPPER_DEFAULT_MAX_ALLOWED_WORKERS = 20;
	
	@Autowired
	NfInstancesRepository nfInstancesRepository;
	
	@Autowired
	private NrfConfigurations nrfConfig;
	
	public int maxAllowedWorkers;
	
	private ForwardingData forwardingData;
	
	private HttpServletRequest request;
	
	private NrfSystemOptions nrfSystemOptions;
	
	private NrfEngSystemOptions nrfEngSystemOptions;
	
	@Autowired
	public void setNrfConfig(NrfConfigurations config) {
		Map<String, Object> logMsg = new LinkedHashMap<String, Object>();
		if(config==null || config.getDiscSvc()==null || config.getGlobalConfig()== null) {
			throw new NrfConfigException("Bad NRF configuration. Missing 'nrf.disc-svc.*' or 'nrf.global' properties.");
		}
		this.nrfConfig = config;
		
		this.maxAllowedWorkers = nrfConfig.getDiscSvc().getMaxThreadPoolSize();
		if(this.maxAllowedWorkers < 1 || this.maxAllowedWorkers > UPPER_DEFAULT_MAX_ALLOWED_WORKERS) {
			logMsg.clear();
			logMsg.put("logMsg", "Invalid 'nrf.disc-svc.thread-pool-size' property. The value should be between 1 and upperDefaultMaxAllowedWorkers");
			logMsg.put("upperDefaultMaxAllowedWorkers", UPPER_DEFAULT_MAX_ALLOWED_WORKERS);
			logger.error(logMsg.toString());
		}
		this.maxAllowedWorkers = Math.max(LOWER_DEFAULT_MAX_ALLOWED_WORKERS,
								Math.min(this.maxAllowedWorkers, UPPER_DEFAULT_MAX_ALLOWED_WORKERS));
		//logger.info("Considering nrf.disc-svc.thread-pool-size = "+this.maxAllowedWorkers);
		logMsg.clear();
		logMsg.put("logMsg", "Considering nrf.disc-svc.thread-pool-size");
		logMsg.put("maxAllowedWorkers", this.maxAllowedWorkers);
		logger.info(logMsg.toString());
	}



	public GenericResponse performNfAuthentication(String requesterNfInstanceFqdn) throws NrfException {

		Map<String, Object> logMsg = new LinkedHashMap<String, Object>();
		String ocXfccDnsHeaderValue = parseOcXfccDnsHeader();
		logMsg.clear();
		logMsg.put("logMsg", "Entering performNfAuthentication");
		logMsg.put("isForwarded",forwardingData.isForwarded());
		logMsg.put("ocXfccDnsHeaderValue",ocXfccDnsHeaderValue);
		logger.info(logMsg.toString());
		
		GenericResponse genericResponse = new GenericResponse();
		if(ocXfccDnsHeaderValue == null) {
			ProblemDetails prob = ProblemDetails.forInternalError();
			prob.setCause("OC-XFCC-DNS header not recieved from Gateway");
			genericResponse.setResponse(prob);
			logMsg.clear();
			logMsg.put("logMsg", "NF Authentication failed for service operation NFDiscover");
			logMsg.put("isForwarded",forwardingData.isForwarded());
			logMsg.put("ocXfccDnsHeaderValue",ocXfccDnsHeaderValue);
			logMsg.put("requesterNfInstanceFqdn",requesterNfInstanceFqdn);
			logMsg.put("Generic Response", genericResponse);
			logger.error(logMsg.toString());
			return (genericResponse);
		}
		
		if(!forwardingData.isForwarded()) {
			/*
			 * Forwarding NRF should performs authentication
			 */
			return validateOriginalRequest(requesterNfInstanceFqdn,ocXfccDnsHeaderValue);
		}
		
		genericResponse.setResponse(null);
		logMsg.clear();
		logMsg.put("logMsg", "Returning from performNfAuthentication");
		logMsg.put("logMsg", "not handling forwarded request");
		logMsg.put("Generic Response", genericResponse);
		logger.info(logMsg.toString());
		return (genericResponse);
	}
	
	private GenericResponse validateOriginalRequest(String requesterNfInstanceFqdn,String ocXfccDnsHeaderValue) {
		// TODO Auto-generated method stub
		Map<String, Object> logMsg = new LinkedHashMap<String, Object>();
		logMsg.clear();
		logMsg.put("logMsg", "validateOriginalRequest");
		logger.info(logMsg.toString());
		List<NfInstance> nfList = null;
		Object result = null;
		CommonService commonService = null;
		List<NfInstance> nfInstanceList = null;
		String failureCondition = null;
		GenericResponse genericResponse = new GenericResponse();
		boolean sendNfAuthenticationFailure = false;
		/* fetching status is enabled to check against all registered fqdns */
		FeatureStatus checkIfNfIsRegistered = nrfSystemOptions.getNfAuthenticationSystemOptions()
				.getCheckIfNfIsRegistered();
		/*
		 * if requester nf instance fqdn is not present in request URI query parameters
		 */
		if (requesterNfInstanceFqdn == null) {
			/*
			 * if requester nf instance fqdn is not present in request URI query parameters
			 * so checking against all registered fqdns
			 */
			if (checkIfNfIsRegistered.equals(FeatureStatus.ENABLED)) {
				try {
					nfInstanceList = nfInstancesRepository.findByNfStatus(NFStatus.REGISTERED);
				} catch (Exception e) {
					ProblemDetails prob = ProblemDetails.forInternalError();
					prob.setCause("Could not fetch NfProfile due to an unexpected error.");
					logMsg.clear();
					logMsg.put("logMsg", e.getMessage());
					logMsg.put("stackTrace", (Object[]) e.getStackTrace());
					logMsg.put("problemDetails", prob);
					logMsg.put("checkIfNfIsRegistered", checkIfNfIsRegistered);
					logger.error(logMsg.toString());
					genericResponse.setResponse(prob);
					return (genericResponse);
				}
				if (nfInstanceList != null && !nfInstanceList.isEmpty()) {

					// Get latest record for each nfInstanceId
					Collections.sort(nfInstanceList, new NfInstanceSortComparator());
					nfList = new ArrayList<NfInstance>();
					for (NfInstance nf : nfInstanceList) {
						if (!nfList.stream().anyMatch(pf -> pf.getNfInstanceId().equals(nf.getNfInstanceId()))) {
							nfList.add(nf);
						}
					}
					// if replication inactive, return only own records.
					if (!NrfServiceStatus.getReplicationStatus() && (nfList != null && !nfList.isEmpty())) {
						logMsg.clear();
						logMsg.put("logMsg", "Replication inactive. Return only own records");
						logger.warn(logMsg.toString());
						List<NfInstance> ownNfInstances = nfList.stream().filter(
								nf -> nf.getRecordOwner().equals(nrfConfig.getGlobalConfig().getNrfInstanceId()))
								.collect(Collectors.toList());
						nfList = ownNfInstances;
					}
					/*
					 * If replication is inactive do lookup of registered fqdns only against own
					 * records
					 */
					if (nfList != null && !nfList.isEmpty()) {
						commonService = new CommonServiceImpl();
						result = commonService.spawnRegisteredFqdnLookupThreads(nfList, maxAllowedWorkers,
								nrfConfig.getDiscSvc().getWaitTime());

						if (result instanceof List<?>) {
							List<String> registeredFqdnList = (ArrayList<String>) result;
							if (!registeredFqdnList.contains(ocXfccDnsHeaderValue)) {
								failureCondition = "fqdn in ocXfccDnsHeader doesnot match with registered fqdns";
								sendNfAuthenticationFailure = true;
							}
						} else {
							ProblemDetails prob = ProblemDetails.forInternalError();
							prob.setCause("Failed to fetch fqdn list from registered profiles");
							genericResponse.setResponse(prob);
							logMsg.clear();
							logMsg.put("logMsg", "NF Authentication failed for NfDiscover service operation");
							logMsg.put("checkIfNfIsRegistered", checkIfNfIsRegistered);
							logMsg.put("requesterNfInstanceFqdn", requesterNfInstanceFqdn);
							logMsg.put("Generic Response", genericResponse);
							logger.error(logMsg.toString());
							return (genericResponse);
						}
					} else {
						/* No registered fqdns found with replication inactive */
						failureCondition = "Couldnot authenticate NF using FQDN,no profiles present in database with status REGISTERED.";
						sendNfAuthenticationFailure = true;
					}
					/* If no registered profile is available return problem details */
				}else {
					failureCondition = "Couldnot authenticate NF using FQDN,no profiles present in database with status REGISTERED.";
					sendNfAuthenticationFailure = true;
				}
			} else {
				// if requester nf instance fqdn is not present in request URI query parameters
				// and checking against all registered fqdn is disabled
				sendNfAuthenticationFailure = true;
				failureCondition = "requester NF instance fqdn not present in query parameters and check against all registered fqdn disabled";
			}
		} else {
			// if validation of fqdn received in request fails with oc-xfcc-dns header
			if (!requesterNfInstanceFqdn.equals(ocXfccDnsHeaderValue)) {
				sendNfAuthenticationFailure = true;
				failureCondition = "requester NF instance fqdn doesnot match with oc-xfcc-dns header value";
			}
		}

		if (sendNfAuthenticationFailure) {
			GenericResponse retValueWithHeaders = getNfAuthenticationFailureResponseByErrorCondition(
					ErrorCondition.Nf_Fqdn_Authentication_Failure);
			ProblemDetails problemDetails = (ProblemDetails) retValueWithHeaders.getResponse();
			HttpHeaders httpHeaders = (HttpHeaders) retValueWithHeaders.getHeaders();
			problemDetails.setCause(failureCondition);
			genericResponse.setResponse(problemDetails);
			genericResponse.setHeaders(httpHeaders);
			logMsg.clear();
			logMsg.put("logMsg", "NF Authentication failed for service opertation NfDiscover");
			logMsg.put("getReplicationStatus",String.valueOf(NrfServiceStatus.getReplicationStatus()));
			logMsg.put("checkIfNfIsRegistered", checkIfNfIsRegistered);
			logMsg.put("requesterNfInstanceFqdn", requesterNfInstanceFqdn);
			logMsg.put("Generic Response", genericResponse);
			logger.error(logMsg.toString());
			return genericResponse;
		}

		genericResponse.setResponse(null);
		logMsg.clear();
		logMsg.put("logMsg", "Returning from validateOriginalRequest");
		logMsg.put("getReplicationStatus",String.valueOf(NrfServiceStatus.getReplicationStatus()));
		logMsg.put("Msg", "Nf Authentication successful");
		logMsg.put("Generic Response", genericResponse);
		logger.info(logMsg.toString());
		return (genericResponse);
	}

	public String parseOcXfccDnsHeader() {
		Map<String, Object> logMsg = new LinkedHashMap<String, Object>();
		logMsg.clear();
		logMsg.put("logMsg", "Parsing OC-XFCC-DNS  header");
		logger.info(logMsg.toString());
		String ocDnsHeaderValue = this.request.getHeader("OC-XFCC-DNS");
		logMsg.put("OC-XFCC-DNS header recieved with value", ocDnsHeaderValue);
		if(ocDnsHeaderValue == null) {
			logMsg.clear();
			logger.warn(logMsg.toString());
		}else {
			logger.info(logMsg.toString());
		}
		return ocDnsHeaderValue;
	}

	
	public void setValidationParameters(ForwardingData forwardingData,HttpServletRequest request,NrfSystemOptions nrfSystemOptions,NrfEngSystemOptions nrfEngSystemOptions) {
		
		this.forwardingData = forwardingData;
		this.request = request;
		this.nrfSystemOptions = nrfSystemOptions;
		this.nrfEngSystemOptions = nrfEngSystemOptions;
		
	}
	
	public GenericResponse getNfAuthenticationFailureResponseByErrorCondition(ErrorCondition errCondition) {
		List<ErrorInfo> errorInfoList = nrfSystemOptions.getNfAuthenticationSystemOptions()
				.getNfAuthenticationErrorResponses();
		ProblemDetails prob = null;
		Object retVal = null;
		GenericResponse genericResponse = new GenericResponse();
		Map<String, Object> logMsg = new LinkedHashMap<String, Object>();
		logMsg.clear();
		logMsg.put("logMsg", "Entering getNfAuthenticationFailureResponseByErrorCondition function");
		logMsg.put("errCondition", errCondition);
		logMsg.put("errorInfoList", errorInfoList);
		logger.error(logMsg.toString());
		for (ErrorInfo errorInfo : errorInfoList) {
			if (errorInfo.getErrorCondition().equals(errCondition)) {
				logMsg.clear();
				logMsg.put("logMsg", "errorInfo selected for errCondition : " + errCondition);
				logMsg.put("errorInfo.errorCode", errorInfo.getErrorCode());
				logMsg.put("errorInfo.errorResponse", errorInfo.getErrorResponse());
				logger.error(logMsg.toString());

				List<String> retryAfterErrorCodesList = nrfEngSystemOptions.getGeneralEngSystemOptions()
						.getRetryAfterErrorCodes();
				List<String> redirectURLErrorCodesList = nrfEngSystemOptions.getGeneralEngSystemOptions()
						.getRedirectUrlErrorCodes();
				int errorCode = errorInfo.getErrorCode();
				String errorCodeGroup = null;

				if (HttpStatus.valueOf(errorCode).is3xxRedirection()) {
					errorCodeGroup = "3xx";
				} else if (HttpStatus.valueOf(errorCode).is4xxClientError()) {
					errorCodeGroup = "4xx";
				} else if (HttpStatus.valueOf(errorCode).is5xxServerError()) {
					errorCodeGroup = "5xx";
				}

				
				if (retryAfterErrorCodesList != null && (retryAfterErrorCodesList.contains(String.valueOf(errorCode))
						|| retryAfterErrorCodesList.contains(errorCodeGroup))) {
					if (errorInfo.getRetryAfter() != null) {
						genericResponse.addHeader(HttpHeaders.RETRY_AFTER, String.valueOf(errorInfo.getRetryAfter().toSeconds()));
					} else {
						logMsg.clear();
						logMsg.put("logMsg", "Cannot set HttpHeaders.RETRY_AFTER as errorInfo RetryAfter is null");
						logger.error(logMsg.toString());
					}

				}

				if (redirectURLErrorCodesList != null && (redirectURLErrorCodesList.contains(String.valueOf(errorCode))
						|| redirectURLErrorCodesList.contains(errorCodeGroup))) {
					if (errorInfo.getRedirectUrl() != null) {
						genericResponse.addHeader(HttpHeaders.LOCATION, errorInfo.getRedirectUrl());
					} else {
						logMsg.clear();
						logMsg.put("logMsg", "Cannot set HttpHeaders.LOCATION as errorInfo RedirectURL is null");
						logger.error(logMsg.toString());
					}
				}

				prob = new ProblemDetails();
				prob.setStatus((int) errorInfo.getErrorCode());
				prob.setDetail(errorInfo.getErrorResponse());
				prob.setTitle(errorInfo.getErrorResponse());
				prob.setCause(errorInfo.getErrorResponse());

				genericResponse.setResponse(prob);
				genericResponse.setHeaders(httpHeaders);

				logMsg.clear();
				logMsg.put("logMsg", "Exit from getNfAuthenticationFailureResponseByErrorCondition function");
				logMsg.put("value", genericResponse);
				logger.info(logMsg.toString());
				return genericResponse;

			}
		}
		logMsg.clear();
		logMsg.put("logMsg", "Exit from getNfAuthenticationFailureResponseByErrorCondition function");
		logger.info(logMsg.toString());
		genericResponse.setResponse(retVal);
		return genericResponse;
	}



}
